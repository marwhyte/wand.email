'use server'

import { uploadFile } from '@/app/actions/uploadFile'
import { getImgFromKey } from '@/lib/utils/misc'
import { google } from '@ai-sdk/google'
import { generateText, NoImageGeneratedError } from 'ai'
import namer from 'color-namer'
import { createClient } from 'pexels'

// Initialize the Pexels client
const pexelsClient = createClient(process.env.PEXELS_API_KEY || '')

// Get descriptive color name for prompting
const getColorDescription = (hexColor: string): string => {
  const colorNames = namer(hexColor)
  return `${colorNames.basic[0].name}, resembling ${colorNames.ntc[0].name}`
}

export type ImageAspectRatio = '1:1' | '3:4' | '4:3' | '9:16' | '16:9'

export async function resolveImageSrc(
  src: string,
  aspectRatio: ImageAspectRatio = '16:9',
  hasHitLimit: boolean = false,
  themeColor: string
): Promise<string> {
  // Check if this is a service-based image request
  const match = src.match(/^(\w+):(.+)$/)

  if (!match) {
    return src // Return as-is if not a service request
  }

  const [_, service, keyword] = match

  // If user has hit the limit, use Pexels regardless of the requested service
  if (hasHitLimit && service.toLowerCase() === 'imagegen') {
    console.log(`User has hit image limit, using Pexels instead for: ${keyword}`)
    return getFallbackPexelsImage(keyword, aspectRatio)
  }

  switch (service.toLowerCase()) {
    case 'imagegen':
      // Mark this image as being generated
      console.log(`Starting generation for ${src}`)

      try {
        const colorDescription = getColorDescription(themeColor)
        console.log('Generating image with prompt for color:', colorDescription)

        // Use Google's generative AI model for image generation
        const result = await generateText({
          model: google('gemini-2.0-flash-exp'),
          providerOptions: {
            google: { responseModalities: ['TEXT', 'IMAGE'] },
          },
          prompt: `Create a marketing-style visual that shows: ${keyword}. 
                  Modern, clean illustration in a light theme with ${colorDescription} color accents.
                  Professional, minimalist style with soft glowing elements and a clean background.`,
        })

        // Capture a reference to the result for error handling
        const resultRef = result

        // Handle the generated image
        const files = result.files || []

        console.log(
          'Generated result structure:',
          JSON.stringify({
            hasFiles: !!files,
            fileCount: files?.length || 0,
            resultKeys: Object.keys(result),
          })
        )

        if (files && files.length > 0) {
          try {
            console.log('Image successfully generated, processing first file')

            // Get the first generated image file
            const imageFile = files[0]
            console.log('First file type:', typeof imageFile)

            if (typeof imageFile === 'object' && imageFile !== null) {
              console.log('File object keys:', Object.keys(imageFile))
            }

            // Upload the image to S3
            const imageUrl = await uploadAiGeneratedImage(imageFile, keyword, aspectRatio)

            // Store the URL
            console.log(`Setting image URL for ${src} to`, imageUrl.substring(0, 50) + '...')
            return imageUrl
          } catch (error) {
            console.error('Error processing AI image:', error)
            // Immediately fall back to Pexels
            console.log('Falling back to Pexels due to image processing error')
            const fallbackUrl = await getFallbackPexelsImage(keyword, aspectRatio)
            console.log(`Setting image URL for ${src} to Pexels fallback:`, fallbackUrl.substring(0, 50) + '...')
            return fallbackUrl
          }
        }

        // If we reached here, no image was generated, fall back to Pexels
        console.error('AI_NoImageGeneratedError: No image was generated by the AI model', {
          keyword,
          aspectRatio,
          themeColor,
          colorDescription: getColorDescription(themeColor),
          cause:
            'The AI model did not return an image object. This could be due to content safety filters, invalid prompt, or API limitations.',
        })
        console.log('No image generated by AI, falling back to Pexels')
        const noImageFallbackUrl = await getFallbackPexelsImage(keyword, aspectRatio)
        console.log(
          `Setting image URL for ${src} to Pexels fallback (no image generated):`,
          noImageFallbackUrl.substring(0, 50) + '...'
        )
        return noImageFallbackUrl
      } catch (error: any) {
        // Check if this is specifically a NoImageGeneratedError
        if (NoImageGeneratedError.isInstance(error)) {
          console.error('AI_NoImageGeneratedError occurred:', {
            message: error.message,
            cause: error.cause,
            responses: error.responses,
            keyword,
            aspectRatio,
            themeColor,
          })
          console.log('Error cause details:', error.cause)
          console.log('Responses from model:', error.responses)
        } else {
          console.error('Error generating AI image:', error)

          // Provide more detailed diagnostics for the specific type error
          if (error.message?.includes('Cannot read properties') || error.message?.includes('type')) {
            console.log('This appears to be a DefaultGeneratedFile handling error.')
          }

          console.error('Error details:', {
            errorMessage: error.message,
            errorName: error.name,
            errorStack: error.stack,
            errorCause: error.cause,
            errorCode: error.code,
            errorStatus: error.status,
            errorResponse: error.response?.data || error.response,
          })
        }

        // Fall back to Pexels
        console.log('Falling back to Pexels due to AI generation error')
        const fallbackUrl = await getFallbackPexelsImage(keyword, aspectRatio)
        console.log(
          `Setting image URL for ${src} to Pexels fallback (generation error):`,
          fallbackUrl.substring(0, 50) + '...'
        )
        return fallbackUrl
      }

    case 'pexels':
      return getFallbackPexelsImage(keyword, aspectRatio)

    default:
      return src
  }
}

// Convert aspect ratio to Pexels orientation format
function aspectRatioToPexelsOrientation(
  aspectRatio: '1:1' | '3:4' | '4:3' | '9:16' | '16:9'
): 'landscape' | 'portrait' | 'square' {
  switch (aspectRatio) {
    case '16:9':
    case '4:3':
      return 'landscape'
    case '9:16':
    case '3:4':
      return 'portrait'
    case '1:1':
      return 'square'
    default:
      return 'landscape'
  }
}

// Helper function to get Pexels image
async function getFallbackPexelsImage(
  keyword: string,
  aspectRatio: '1:1' | '3:4' | '4:3' | '9:16' | '16:9'
): Promise<string> {
  try {
    // Convert aspect ratio to Pexels-compatible orientation format
    const pexelsOrientation = aspectRatioToPexelsOrientation(aspectRatio)

    const result = await pexelsClient.photos.search({
      query: keyword,
      per_page: 1,
      orientation: pexelsOrientation,
      color: '#f4f4f4',
    })

    if ('error' in result) {
      console.error('Pexels API error:', result.error)
      return `pexels:${keyword}` // Return original source
    }

    const photo = result.photos[0]
    return photo?.src.large || `pexels:${keyword}`
  } catch (error) {
    console.error('Error fetching Pexels image:', error)
    return `pexels:${keyword}` // Return original source
  }
}

// Helper to upload AI-generated image to S3
async function uploadAiGeneratedImage(
  file: any,
  keyword: string,
  aspectRatio: '1:1' | '3:4' | '4:3' | '9:16' | '16:9'
): Promise<string> {
  try {
    console.log('uploadAiGeneratedImage received file of type:', typeof file)

    // Log environment info for debugging
    console.log('Environment:', {
      NODE_ENV: process.env.NODE_ENV,
      isVercel: !!process.env.VERCEL,
      isS3Available: !!process.env.AWS_S3_BUCKET_NAME,
    })

    // Handle the image data based on its type
    let blob: Blob
    let mimeType = 'image/png' // Default mime type

    if (file instanceof Blob) {
      console.log('File is a Blob with type:', file.type)
      // Already a Blob, use directly
      blob = file
      mimeType = file.type || mimeType
    } else if (typeof file === 'string' && file.startsWith('data:')) {
      console.log('File is a data URL')
      // Handle data URLs (base64 encoded images)
      const matches = file.match(/^data:([A-Za-z-+/]+);base64,(.+)$/)
      if (matches && matches.length === 3) {
        const type = matches[1]
        const base64Data = matches[2]
        const binaryString = atob(base64Data)
        const bytes = new Uint8Array(binaryString.length)
        for (let i = 0; i < binaryString.length; i++) {
          bytes[i] = binaryString.charCodeAt(i)
        }
        blob = new Blob([bytes], { type })
        mimeType = type
      } else {
        throw new Error('Invalid data URL format')
      }
    } else if (file.mimeType && (file instanceof File || typeof file.arrayBuffer === 'function')) {
      console.log('File has mimeType property:', file.mimeType)
      // Handle File or File-like objects with mimeType
      blob = file as unknown as Blob
      mimeType = file.mimeType
    } else {
      // Unknown format, try to use as is
      console.warn('Unknown image format, attempting to use as blob')
      console.log(
        'File details:',
        file ? Object.getOwnPropertyNames(file) : 'null/undefined',
        'Constructor:',
        file ? file.constructor?.name : 'unknown'
      )
      if (file && typeof file === 'object') {
        console.log('Available properties:', Object.keys(file))
        if ('buffer' in file) console.log('Has buffer property, type:', typeof file.buffer)
        if ('data' in file) console.log('Has data property, type:', typeof file.data)
      }

      // Handle DefaultGeneratedFile from Vertex AI
      if (file && typeof file === 'object' && 'base64Data' in file && 'mimeType' in file) {
        console.log('Processing DefaultGeneratedFile from Vertex AI')
        try {
          // Create a variable to hold the Blob
          let vertexBlob: Blob | null = null
          let vertexMimeType = file.mimeType || 'image/png'

          // Use the base64Data if available
          if (file.base64Data && typeof file.base64Data === 'string') {
            console.log('Using base64Data from DefaultGeneratedFile, length:', file.base64Data.length)

            // Check if the base64 data is prefixed
            const hasPrefix = file.base64Data.startsWith('data:')

            // If base64Data doesn't have the data:image prefix, add it
            let base64DataWithPrefix = file.base64Data
            if (!hasPrefix) {
              base64DataWithPrefix = `data:${file.mimeType};base64,${file.base64Data}`
              console.log('Added prefix to base64Data')
            }

            try {
              // Parse the data URL
              const matches = hasPrefix
                ? base64DataWithPrefix.match(/^data:([A-Za-z-+/]+);base64,(.+)$/)
                : [null, file.mimeType, file.base64Data]

              if ((hasPrefix && matches && matches.length === 3) || !hasPrefix) {
                const type = hasPrefix ? matches[1] : file.mimeType
                const base64Data = hasPrefix ? matches[2] : file.base64Data

                // Log some diagnostics about the data received
                console.log('Data type:', type, 'base64 length:', base64Data.length)

                try {
                  const binaryString = atob(base64Data)
                  const bytes = new Uint8Array(binaryString.length)
                  for (let i = 0; i < binaryString.length; i++) {
                    bytes[i] = binaryString.charCodeAt(i)
                  }
                  vertexBlob = new Blob([bytes], { type })
                  vertexMimeType = type
                  console.log('Successfully created Blob from base64Data with length:', bytes.length)
                } catch (atobError) {
                  console.error('Error decoding base64 data:', atobError)
                  throw new Error('Invalid base64 data format')
                }
              } else if (hasPrefix) {
                throw new Error('Invalid data URL format in base64Data')
              }
            } catch (parseError) {
              console.error('Error parsing base64 data:', parseError)
              // Fall back to direct base64 conversion
              try {
                const binaryString = atob(file.base64Data)
                const bytes = new Uint8Array(binaryString.length)
                for (let i = 0; i < binaryString.length; i++) {
                  bytes[i] = binaryString.charCodeAt(i)
                }
                vertexBlob = new Blob([bytes], { type: file.mimeType })
                vertexMimeType = file.mimeType
                console.log('Successfully created Blob from raw base64Data with length:', bytes.length)
              } catch (atobError) {
                console.error('Error decoding raw base64 data:', atobError)
                throw new Error('Invalid base64 encoding')
              }
            }
          }
          // Fall back to uint8ArrayData if base64Data processing failed
          else if (file.uint8ArrayData && file.uint8ArrayData instanceof Uint8Array) {
            console.log('Using uint8ArrayData from DefaultGeneratedFile with length:', file.uint8ArrayData.length)
            vertexBlob = new Blob([file.uint8ArrayData], { type: file.mimeType })
            vertexMimeType = file.mimeType
            console.log('Successfully created Blob from uint8ArrayData')
          } else {
            throw new Error('Neither base64Data nor uint8ArrayData are valid')
          }

          // If we successfully created a blob, use it
          if (vertexBlob) {
            blob = vertexBlob
            mimeType = vertexMimeType
          } else {
            throw new Error('Failed to create blob from Vertex AI data')
          }
        } catch (vertexError: any) {
          console.error('Error processing Vertex AI DefaultGeneratedFile:', vertexError.message)
          throw vertexError
        }
      }
      // Try to handle common formats that might not be properly detected
      else if (file && typeof file === 'object' && 'buffer' in file && file.buffer) {
        console.log('Converting buffer to Blob')
        // Try to convert buffer to Blob
        try {
          const arrayBuffer = file.buffer instanceof ArrayBuffer ? file.buffer : new Uint8Array(file.buffer).buffer
          blob = new Blob([arrayBuffer], { type: 'image/png' })
          mimeType = 'image/png'
        } catch (bufferError: any) {
          console.error('Error converting buffer to Blob:', bufferError.message)
          blob = file as unknown as Blob
        }
      } else if (file && typeof file === 'object' && 'data' in file && file.data) {
        console.log('Converting data property to Blob')
        // Try to convert data property to Blob
        try {
          const data = file.data
          if (typeof data === 'string' && data.startsWith('data:')) {
            // Handle data URL
            const matches = data.match(/^data:([A-Za-z-+/]+);base64,(.+)$/)
            if (matches && matches.length === 3) {
              const type = matches[1]
              const base64Data = matches[2]
              const binaryString = atob(base64Data)
              const bytes = new Uint8Array(binaryString.length)
              for (let i = 0; i < binaryString.length; i++) {
                bytes[i] = binaryString.charCodeAt(i)
              }
              blob = new Blob([bytes], { type })
              mimeType = type
            } else {
              throw new Error('Invalid data URL format')
            }
          } else if (data instanceof Uint8Array || data instanceof ArrayBuffer) {
            // Handle binary data
            blob = new Blob([data], { type: 'image/png' })
            mimeType = 'image/png'
          } else {
            throw new Error('Unsupported data format')
          }
        } catch (dataError: any) {
          console.error('Error converting data to Blob:', dataError.message)
          blob = file as unknown as Blob
        }
      } else {
        blob = file as unknown as Blob
      }
    }

    // Get the file extension from mime type
    const extension = mimeType.split('/')[1] || 'png'

    // Create a sanitized filename
    const sanitizedName = `ai-${encodeURIComponent(keyword.slice(0, 30))}-${Date.now()}.${extension}`

    // Create a proper File object
    const imgFile = new File([blob], sanitizedName, { type: mimeType })

    // Create FormData for upload
    const formData = new FormData()
    formData.append('file', imgFile)

    // Get image dimensions based on aspect ratio
    // Use a base size of 1200 pixels (width or height, depending on aspect ratio)
    let width = 1200
    let height = 675 // Default 16:9

    switch (aspectRatio) {
      case '16:9':
        width = 1200
        height = 675 // 16:9
        break
      case '9:16':
        width = 675
        height = 1200 // 9:16
        break
      case '4:3':
        width = 1200
        height = 900 // 4:3
        break
      case '3:4':
        width = 900
        height = 1200 // 3:4
        break
      case '1:1':
        width = 1000
        height = 1000 // 1:1
        break
      default:
        width = 1200
        height = 675 // 16:9
    }

    formData.append('width', width.toString())
    formData.append('height', height.toString())

    // Upload to S3 with retry logic
    let attempts = 0
    const maxAttempts = 2

    while (attempts < maxAttempts) {
      try {
        attempts++
        const uploadResult = await uploadFile(formData, true)

        if (uploadResult.success && uploadResult.file) {
          // Get the CloudFront URL for the uploaded image
          return getImgFromKey(uploadResult.file.imageKey)
        } else {
          console.error(`Upload attempt ${attempts} failed:`, uploadResult.error)
          if (attempts >= maxAttempts) throw new Error(uploadResult.error || 'Failed to upload image')
        }
      } catch (uploadError) {
        console.error(`Upload attempt ${attempts} error:`, uploadError)
        if (attempts >= maxAttempts) throw uploadError
        // Short delay before retry
        await new Promise((resolve) => setTimeout(resolve, 500))
      }
    }

    throw new Error('All upload attempts failed')
  } catch (error) {
    console.error('Error in uploadAiGeneratedImage:', error)
    throw error
  }
}
